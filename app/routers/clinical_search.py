"""Clinical search API.

Exposes an optimized search endpoint over the curated clinical dictionary.
Designed for PostgreSQL + pg_trgm and future ranking extensions.
"""

from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import Session

from app.clinical.suggestions.service import normalize_query, search_clinical_dictionary
from app.db.session import get_db
from app.models.clinical_search_log import ClinicalSearchLog

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/clinical", tags=["clinical-search"])


def _env_truthy(name: str, default: str = "0") -> bool:
    return os.getenv(name, default).strip().lower() in {"1", "true", "yes", "on"}


DISABLE_SEARCH_LOGGING = _env_truthy("CLINICAL_SEARCH_DISABLE_LOGGING", default="1")
DEBUG_MODE = _env_truthy("CLINICAL_CORE_DEBUG", default="0")


@router.get("/search")
def clinical_search(
    q: str = Query(..., min_length=1, description="Clinical search query"),
    limit: int = Query(20, ge=1, le=100, description="Max results (<= 100)"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    specialty: Optional[str] = Query(default=None, description="Optional specialty to boost relevance"),
    user_id: Optional[int] = Query(default=None, description="Optional user id for future personalization"),
    db: Session = Depends(get_db),
) -> list[dict]:
    query = normalize_query(q)
    if not query:
        raise HTTPException(status_code=400, detail="q must not be empty")

    specialty_norm = normalize_query(specialty) if specialty is not None else None
    if specialty is not None and not specialty_norm:
        raise HTTPException(status_code=400, detail="specialty must not be empty when provided")

    logger.info("/clinical/search normalized_query=%r specialty=%r", query, specialty_norm)

    try:
        results = search_clinical_dictionary(
            db,
            query,
            specialty=specialty_norm,
            limit=limit,
            offset=offset,
        )

        # Temporarily disabled by default to isolate failures.
        if not DISABLE_SEARCH_LOGGING:
            try:
                selected_term = query.strip()
                if not selected_term:
                    raise ValueError("selected_term must not be empty")

                # created_at is server-generated by DB default; do not send NULL.
                with db.begin():
                    db.add(
                        ClinicalSearchLog(
                            user_id=user_id,
                            query=query,
                            selected_term=selected_term,
                            specialty=specialty_norm,
                        )
                    )
            except Exception:
                logger.exception("Search logging failed (ignored)")

        return results

    except Exception as exc:
        logger.exception("clinical search failed")
        if DEBUG_MODE:
            raise HTTPException(status_code=500, detail=f"clinical search failed: {exc}")
        raise HTTPException(status_code=500, detail="clinical search failed")
